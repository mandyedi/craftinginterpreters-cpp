// generateAST.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

/*
	Tool for generateing abstract syntax tree
	Output is Expr.cpp
*/

#include <fstream>
#include <vector>
#include <sstream>
#include <iostream>

void defineAst( std::ofstream &outputStream, const std::string &baseName, const std::vector<std::string> &types );
void defineType( std::ofstream &outputStream, const std::string &baseName, const std::string &className, const std::string &fieldList );
void defineVisitor( std::ofstream &outputStream, const std::string &baseName, const std::vector<std::string> &types );
void split( const std::string &line, char delimiter, std::vector<std::string> &tokens );
std::string trim( const std::string &line );
std::string capitalize( const std::string &s );

int main( int argc, char **argv )
{
	std::ofstream outputStream;
	outputStream.open( "..\\lox\\Expr.h" );

	defineAst( outputStream, "Expr", {
		"Binary   : Expr *left, Token op, Expr *right",
		"Grouping : Expr *expression",
		"Literal  : Object value",
		"Unary    : Token op, Expr *right"
		} );

	outputStream.close();

	return 0;
}

void defineAst( std::ofstream &outputStream, const std::string &baseName, const std::vector<std::string> &types )
{
	outputStream << "#ifndef EXPR_H\n#define EXPR_H\n\n";
	
	outputStream << "/*\n    This file is automatically generated by generateAST on every lox build.\n";
	outputStream << "    Any manually added or changed content is going to be removed.\n*/\n\n";
	
	outputStream << "#include \"Token.h\"\n\n";

	defineVisitor( outputStream, baseName, types );

	outputStream << "class " << baseName << "\n{\n";
	outputStream << "public:\n";
	outputStream << "    virtual ~" << baseName << "() {}\n";
	outputStream << "    virtual void Accept( class Visitor *visitor ) = 0;\n";
	outputStream << "};\n\n";

	for ( auto &type : types )
	{
		std::vector<std::string> tokens;
		split( type, ':', tokens );
		std::string className = trim( tokens[0] );
		std::string fields = trim( tokens[1] );
		defineType( outputStream, baseName, className, fields );
	}

	outputStream << "#endif EXPR_H // EXPR_H\n";
}

void defineType( std::ofstream &outputStream, const std::string &baseName, const std::string &className, const std::string &fieldList )
{
	outputStream << "class " << className << " : public " << baseName << "\n{\n";
	outputStream << "public:\n";

	// Constructor
	outputStream << "    " << className << "( " << fieldList << " )\n";
	// Store paramters
	std::vector<std::string> fields;
	split( fieldList, ',', fields );
	for ( unsigned int i = 0; i < fields.size(); i++ )
	{
		std::vector<std::string> fieldItems;
		split( trim( fields[i] ), ' ', fieldItems );
		std::string name = trim( fieldItems[1] );
		if ( name[0] == '*' )
		{
			name = name.substr( 1, name.size() - 1 );
		}
		std::string nameCap = capitalize( name );
		outputStream << "    " << (i == 0 ? ": " : ", ") << nameCap << "(" << name << ")\n";
	}
	outputStream << "{}\n\n";

	// Visitor pattern

	outputStream << "    void Accept( Visitor *visitor ) override\n    {\n";
	outputStream << "        return visitor->Visit" << className << baseName << "( this );\n    }\n\n";

	// Paramters
	for ( auto &field : fields )
	{
		field = trim( field );
		std::vector<std::string> tokens;
		split( field, ' ', tokens );

		// Class parameters needs to be capitalzed
		outputStream << "    " << tokens[0] << " " << capitalize( tokens[1] ) << ";\n";
	}

	outputStream << "};\n\n";
}

void defineVisitor( std::ofstream &outputStream, const std::string &baseName, const std::vector<std::string> &types )
{
	outputStream << "class Visitor\n{\n";
	outputStream << "public:\n";
	outputStream << "    virtual ~Visitor() {};\n";

	for ( auto &type : types )
	{
		std::vector<std::string> tokens;
		split( type, ':', tokens );
		std::string typeName = trim( tokens[0] );
		std::string baseNameDecap = baseName;
		baseNameDecap[0] = std::tolower( baseNameDecap[0] );
		outputStream << "    virtual void Visit" << typeName << baseName << "( class " << typeName << " *" << baseNameDecap << " ) = 0;\n";
	}

	outputStream << "};\n\n";
}

void split( const std::string &line, char delimiter, std::vector<std::string> &tokens )
{
	tokens.clear();
	std::stringstream lineStream( line );
	std::string token;
	while ( getline( lineStream, token, delimiter ) )
	{
		tokens.push_back( token );
	}
}

std::string trim( const std::string &line )
{
	const std::string spaces = " \t\v\r\n\f";

	size_t start = line.find_first_not_of( spaces );
	std::string trimmedLine = (start == std::string::npos) ? "" : line.substr( start );

	size_t end = trimmedLine.find_last_not_of( spaces );
	trimmedLine = (end == std::string::npos) ? "" : trimmedLine.substr( 0, end + 1 );

	return trimmedLine;
}

std::string capitalize( const std::string &s )
{
	std::string s2 = s;
	size_t i = s2.find_first_not_of( '*' );
	if ( i != std::string::npos )
	{
		s2[i] = std::toupper( s2[i] );
	}
	return s2;
}
